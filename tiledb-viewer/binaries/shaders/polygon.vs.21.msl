#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct type_ConstantBuffer_VertShaderUniforms
{
    float scaleA;
    float scaleB;
    float time;
    float aspectRatio;
    float theta;
};

struct VSMain_out
{
    float4 out_var_NGF_COLOR [[user(locn0)]];
    float4 gl_Position [[position]];
};

vertex VSMain_out VSMain(constant type_ConstantBuffer_VertShaderUniforms& vertShaderUniforms [[buffer(0)]], uint gl_VertexIndex [[vertex_id]])
{
    VSMain_out out = {};
    float4 _89;
    float4 _90;
    if ((gl_VertexIndex % 3u) == 0u)
    {
        _89 = float4(0.0, 0.0, 0.0, 1.0);
        _90 = float4(0.800000011920928955078125, 0.699999988079071044921875, 0.800000011920928955078125, 1.0);
    }
    else
    {
        float _47 = cos(vertShaderUniforms.time);
        float _48 = sin(vertShaderUniforms.time);
        float _67 = float(int(rint(float(gl_VertexIndex) * 0.3333333432674407958984375))) * vertShaderUniforms.theta;
        float2 _76 = ((float2(sin(_67), cos(_67)) * float2x2(float2(_47, -_48), float2(_48, _47))) * float2(1.0, vertShaderUniforms.aspectRatio)) * (((gl_VertexIndex % 2u) != 0u) ? vertShaderUniforms.scaleB : vertShaderUniforms.scaleA);
        float _77 = _76.x;
        float _78 = _76.y;
        float4 _79 = float4(_77, _78, 0.0, 1.0);
        _79.y = _78 * (-1.0);
        _89 = _79;
        _90 = float4(0.5 * (_77 + 1.0), 0.5 * (_78 + 1.0), abs(1.0 - _77), 1.0);
    }
    out.gl_Position = _89;
    out.out_var_NGF_COLOR = _90;
    return out;
}

/**NGF_NATIVE_BINDING_MAP
(0 0) : 0
(-1 -1) : -1
**/
